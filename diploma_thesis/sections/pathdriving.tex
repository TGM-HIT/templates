\cfoot{Hannah Siegel}
One important aspect of the \textit{RoboNav} project is the path-planing based on information gathered from the overhead camera (see also section \ref{subsec:pathplanning}). The robot can make a request to the \textit{RoboNav Control} with coordinates it want to drive to or a request can be send over the \textit{RoboNav Overview}. This section discusses the path-driving functionality in detail.
%The robot should be able to move to a destination a corresponding path-driving function is needed as well. \\
%Once the target of the robot is known and the path planning algorithm (section \ref{subsec:pathplanning}) has calculated the fastest path avoiding obstacles the path will be driven. \\
%The Path-driver's duty is it to let a mobile vehicle - in the case of this project this is exclusively the \textit{Robotino v3} - drive this path very accurately.
\subsubsection{High-level path-driving of the Robonav Control with Java}
\label{subsubsec:pathdrivinghighlevel}
Whenever the robot has to move to a certain point, a \texttt{DrivablePath} object, which is implementing the \texttt{Path} interface, is generated by the path planning algorithm. A  \texttt{DrivablePath}, generated by the path-planning software, acts as the component containing the right information needed for the path driving. \\
In order to enable the \textit{Robotino v3} as an actual device to move on the course of the \texttt{DrivablePath}, a class called \texttt{RobotinoPathDriver} was implemented which extends the super class \texttt{PathDriver}.\insertpicture{images/uml_pathdriver}{Path-driving \gls{UML}}{(selfmade)}{fig:pathdriveruml}{1.0}
The program flow is as follows:
\begin{enumerate}
\item A path-request was either done by the robot (see section \ref{subsec:robotinoview} for details) or over the \textit{Robonav Overview}.
\item When requested, a new path is generated by the path planning and stored in an \texttt{DrivablePath} object. This happens in the the \textit{RoboNav Control}. 
\item The \textit{RoboNav Control} charges a \texttt{PathDriver} with the driving logic, by handling the \texttt{DrivablePath} to the \texttt{PathDriver}. The \texttt{RobotinoPathDriver} class encapsulates the path-driving special for the \textit{Robotino v3}. For other robot models, this class must be implemented accordingly. The usage of the Path driver can can be seen in Listing  \ref{ExternalPathDriving}.
\item The \textit{Robotino} brings a powerful Path-following software with its \textit{RobotinoView} Software. \textit{RoboNav} makes use of this by transferring the path information from the \texttt{RobotinoPathDriver} to the \textit{Robotino} using text-files which are read by the \textit{RobotinoView} path-following software. \\
This special software is closely discussed in section \ref{subsubsec:pathdriverRobotino} and the transferring of the files is discussed section \ref{subsec:communicationRobotino}.
%The \texttt{PathDriver} will let the hardware drive a pathway. In the case of \textit{RoboNav} and the \textit{Robotino v3} this has been done using \textit{RobotinoView} since this was easier than implementing it in Java. The function is discussed in section \ref{subsubsec:pathdriverRobotino}. For this purpose the \texttt{DrivablePath} must be transformed into a list of strings and the right commands must be sent to the Robotino using the, in section \ref{subsec:communicationRobotino}, explained file transfer methods for writing and reading remote files. The driving logic itself will then be done by the RobotinoView program so there is no need for complicated calculations within the API and because only command-structures are send the network is not getting used too much and therefore the path-driving is not vulnerable from long latency or network errors.
\end{enumerate}
%A few important steps on the side of the \textit{RoboNav Control} are mainly the right casting of a path to a \texttt{String} list and the correct usage of the commands so that the \textit{RobotinoView} program can make use of the information transmitted.\\ 
The \texttt{DrivablePath} contains a list of \texttt{CoordinateVectors} where each item contains the next node (= point the robot should drive to) as explained in section \ref{subsubsec:graphbasedrepresentation}. \\
These points are treated as sub-paths by the path driving algorithm. The mobile robot drives in a straight movement from the current position to the next point in the list without rotating. At the end of each sub-path the robot may then turn to a specific angle. This is especially convenient if the robot has a grabber or some similar part which may obstruct in any way if not driving with the right angle. \\ In Listing \ref{transformationPathDriving} the transformation of a high-level path to a more low level string list can be seen. The method returns a \texttt{String}-list containing quadruples of data in the form described in Listing   \ref{Resultofthetransformation} (containing an counter, the x and y values and the rotation angle called phi of the next sub-path point). Before storing the x and y values into the list, they are multiplied by 1000, since the \textit{Robotino} works with millimetres, but \textit{RoboNav} uses metres. Additionally, the whole path string must have an terminating statement which is defined by for times zero. This termination statement tells the path driver to wait until a new path command has been sent. 
\begin{lstlisting}[caption = Simplified transformation logic, label = transformationPathDriving]
// transforming the points using a lambda expression
this.getAnchorPoints().forEach(p -> pointsAsStringList.add(ai.getAndIncrement()+" "+p.getX()*1000+" "+p.getY()*1000+" "+p.getPhi()) );
    
// adding the terminatory statement
pointsAsStringList.add("0 0 0 0");
\end{lstlisting}
\begin{lstlisting}[caption = Result of the transformation, label = Resultofthetransformation]
1 1000.0 1000.0 0.0
2 2000.0 1000.0 90.0
3 2500.0 -500.0 180.0
0 0 0 0
\end{lstlisting}
\subsubsection{Controlling the path driver's actions} 
After the path is transformed, the task of transmitting the data to the \textit{Robotino} begins. \\ 
The more low level path driving logic uses five files for communication, as defined in Listing  \ref{filesPathDriving}. These files must get used in the right order and with the right values, in order to ensure that the path-driving software on the \textit{Robotino} which is discussed in section executes the right actions. In Figure \ref{fig:statemachine}, the possible states of the path-driving software can be seen: % Files get used because it is the easiest way of communication and the \textit{RobotinoView} application supports reading and writing files in a very good way.  
\\ 
The path-driver always starts in the \texttt{waiting} state. As soon as a new path is available, it parses each sub step of this path and drives it, the robot is then in the \texttt{driving} state. In case of an emergency stop, the robot stops immediately and goes over to the \texttt{blocked} state. Once the emergency stop is finished, the robot drives on. Finally, if a slow stop was triggered, the robot will just stop when parsing the next subpath, instead of being blocked right away. Once a path has been completely parsed and there is no next sub path available, the robot is done moving and is back in the \texttt{waiting} state again. 
\insertpicture{images/statemachine}{Overview of the path-drivers states}{(self-made)}{fig:statemachine}{1.0}
The actions described in Figure \ref{fig:statemachine} are triggered using the following files: \\ 
The \texttt{RoboNavPath.txt} file contains the subpath list like in Listing \ref{Resultofthetransformation}.\\
The \texttt{RoboNavStopEmergency.txt} file is used for an emergency stop. This means, that if the content of the file is set to \texttt{1}, the robot should stop immediately - regardless of his position. \\
The \texttt{RoboNavStopSlowly.txt} file on the other hand sends the signal for a controlled stop at the next sub-path position of the path. For example, this function may be used if the robot should stop driving the current path, so that he can drive another one immediately but first should stop on the end of a sub-path and not just anywhere.\\
Since these two stop mechanisms can be used at the same time, \textit{RoboNav} used these two files instead of one global stop file whereas \texttt{0} would be no stop, \texttt{1} slow stop and \texttt{2} emergency stop. Further, the files are used at two different positions within the path-driver and it is easier to use two files containing only true or false since they can be directly connected into an \texttt{AND-flag} without an if-statement. Finally, the usage of two files comes with the advantage of no possible race-conditions, since \textit{RoboNav} is the only entity modifying these files. 
\\
The \texttt{RoboNavReadyToBeDriven.txt} file acts as an controlling instance for the \textit{RoboNav Control}: if the contents of the file are set to \texttt{1}, the \textit{Robotino} is currently not engaged in any actions and can be used for navigational purposes. Therefore if the robot is presently driving a path, it will be marked as unavailable. Also, it may happen that the transmission of the file or the path-driving function of the \textit{RobotinoView} did not work immediately or that there is no path-driver program running. Therefore, the \texttt{RoboNavReadyToBeDriven.txt} comes with a second benefit: as long as there is no \texttt{0} in the file, the \textit{Robonav Control} knows, that the driving of the path was not successful and transmits the path again. If after five times re-sending the path the path-driver did not react, the \texttt{CanNotDrivePath} 
exception is thrown, which means that there is no \textit{RobotinoView} file running at all. \\ 
Finally, the \texttt{RoboNavNewPathAvailiabe.txt} file is used to trigger the \textit{RobotinoView} program when a new path is available and that this path should be followed immediately.

\newpage
\begin{lstlisting}[caption = Communication Files and their paths on the Robotino, label = filesPathDriving]
1. REMOTE_FILE_PATH = "/home/robotino/RoboNavPath.txt"
2. REMOTE_FILE_STOP_EMERGENCY = "/home/robotino/RoboNavStopEmergency.txt"
3. REMOTE_FILE_STOP_SLOWLY = "/home/robotino/RoboNavStopSlowly.txt"
4. REMOTE_FILE_READYTOBEDRIVEN = "/home/robotino/RoboNavReadyToBeDriven.txt"
5. REMOTE_FILE_NEWPATH = "/home/robotino/RoboNavNewPathAvailiabe.txt"
\end{lstlisting} 
Even through these file structures may seem unnecessary complicated, they enable an ideal information exchange between the \textit{RoboNav Control} path-driver. The file commands are handled by the \texttt{RobotinoPathDriver} class, which internally is using the \texttt{SSHManager} (Listing \ref{InternalPathDriving}) but the \textit{RoboNav Control} only has to perform the actions described in Listing \ref{ExternalPathDriving} if a path has to be transmitted. \\
\textit{RoboNav} is not using \textit{RNCP} for this communication because the file exchange is easily implemented in Java using the Jsch library and on the \textit{Robotino} side using the file processing of \textit{RobotinoView}. More important, the usage of files opens the possibility to leave the \textit{Robotino} system unaltered. There is no additional need for implementing \textit{RNCP} into all the possible programming interfaces of the \textit{Robotino} since every language can work with files.
\begin{lstlisting}[caption = Internal handling of the path driving using the SSHManager (section \ref{subsec:communicationRobotino}), label = InternalPathDriving]
while(sshman.checkFileContent(Robotino3.REMOTE_FILE_READYTOBEDRIVEN,"1")){ 
    // wait until the robotino is ready for navigation
}

// reset new path flag
sshman.writeFile(Robotino3.REMOTE_FILE_NEWPATH,"0");

// delete old path
sshman.clearFile(Robotino3.REMOTE_FILE_PATH);

// write new path (lines = transformed path to string list)
sshman.writeFile(Robotino3.REMOTE_FILE_PATH,lines);

// signal that a new path is availiable
sshman.writeFile(Robotino3.REMOTE_FILE_NEWPATH,"1");
\end{lstlisting}
\begin{lstlisting}[caption = Actions that need to be performed to trigger the path-driving functionality, label = ExternalPathDriving]
RobotinoPathDriver robotinoPathDriver = new RobotinoPathDriver();
robotinoPathDriver.letDriveThePath(driveablePath,robotino);
\end{lstlisting}


\newpage
\subsubsection{Low-level path-driving on the Robotino using RobotinoView}
\label{subsubsec:pathdriverRobotino}
\textit{RoboNav} provides \textit{RobotinoView} code as an example implementation for using the path-driving functionality in own programs. Furthermore, this code is also used from the \textit{RoboNav} project to let the \textit{Robotino} drive the calculated path. 
%For realizing a path driving logic the following program is written using the graphical programming interface for the \textit{Robotino}, the \textit{RobotinoViewÂ® 3}.\\
The program contains two steps: the first resets the odometry of the \textit{Robotino} to an initial position. The second step actually does the path-driving. This more complex step is now further discussed and can be seen in Figure \ref{fig:overviewpathdriverrobotino}.
% As it can be seen in image \ref{fig:pathdriverstructure} the structure only contains two steps from which the first is only  resetting the odometry. The second step can be seen in figure \ref{fig:overviewpathdriverrobotino}.
 %\insertpicture{images/structure}{Structure of the main program}{(self-made)}{fig:pathdriverstructure}{0.5}
 \insertpicture{images/newpd}{Overview of the path-driving step}{(self-made)}{fig:overviewpathdriverrobotino}{1.0}
Before starting the program, the \texttt{sendResetPathDriverFiles} method of the \texttt{Robotino3} class should be executed. It resets the communication files to their initial values. Additionally, a path gets set which lets the robot drive ten centimetres to the left and back again so the user can see if all systems work fine. %The program step has small text boxes in the picture. A small overview of the program can be gathered therefore but it will be closer described now: 
\subsubsection{New path logic}
After starting the program (preferably over the \textit{Robotino}'s webinterface), it waits for the new-path-command to be sent. In order to send a new path the \\ \texttt{RoboNavNewPathAvailable.txt} must be set to \texttt{0}. Then the path must be written into the file and then the \texttt{RoboNavNewPathAvailable.txt} must be set to \texttt{1}. After that the code which can be seen in Figure \ref{fig:newpath} takes care of the correct interpretation and handling of the new path transmitted. The code appears a little simplified, for example the \texttt{boolean} values must be multiplied by \texttt{1} in order to cast them to \texttt{float} values. This can still be seen in the overall overview program (Figure \ref{fig:overviewpathdriverrobotino}). 
\insertpicture{images/newpath}{New path and next step logic}{(self-made)}{fig:newpath}{1.0}
The new-path-file gets read continuously (though the file reading block) and the first value gets chosen (the float vector block where index 1 is taken). This value is put into an \texttt{AND-flag} which turns \texttt{true} only once even if the input values stay at \texttt{true}. The \texttt{AND-flag} is needed, because this value triggers the Lua-script afterwards. If it would stay \texttt{true} for a longer timespan it would trigger the new path available information over and over again, but the new path is only available once.  \\
Next the Lua-script takes in some information needed for deciding if and how often the path file should be read.  Whenever the output of this script is \texttt{true}, the next sub-path will be read and put into the path driver. If a new path is announced but the old path is not terminated yet, the script must set it's output to true as long as the incremental counter of the path file is \texttt{1} which means that the path is at the beginning. \\
Listing \ref{leftluascript} shows how the five inputs of the Lua-script can be addressed using the variables \texttt{in1} to \texttt{in5}. The output is set using the variable \texttt{out1}. A global variable \texttt{flankcalled} is set if the new path flag was thrown but the other conditions are not \texttt{true} yet. \\
The inputs are:
\begin{enumerate}[topsep=0pt,itemsep=0ex,partopsep=10ex,parsep=1ex]
  \item \texttt{in1 (terminator)} - The value coming from the terminator script. If this value is \texttt{0 (false)}, the robotino is currently not driving any path.
  \item \texttt{in2 (newpathflag)} - The \texttt{AND flag}'s value. If the new-path-file's value has changed it is set to \texttt{ 1 (true)} but only for one cycle.
  \item \texttt{in3 (robotinoStopped)} - The position-reached-value of the path-driver-block. If the \textit{Robotino} has finished the current sub-path this value will be \texttt{1 (true)} just until a new sub-path is passed to the path driver.
  \item \texttt{in4 (pathStep)} - The current step of the path, which is the incremental number in the path file.
  \item \texttt{in5 (nextSubPath)} - If this value is \texttt{1 (true)} the next sub-path should be driven immediately.
\end{enumerate}
%
%terminator = in1;%
%newpathflag = in2;
%robotinoStopped = in3;
%pathStep = in4;
%nextSubPath = in5;
%
\newpage
\begin{lstlisting}[caption = Lua Script, label = leftluascript]
out1 = nextSubPath;
if ( terminator == 0 ) then
	robotinoStopped = 1;
end
if ( newpathflag == 1 ) then
	flankcalled = 1;
end
if (flankcalled == 1 and robotinoStopped == 1 ) then
	out1 = 1;
	if ( pathStep == 1 ) then 
		out1 = nextSubPath;
		flankcalled = 0;
	end
end
\end{lstlisting}
Basically, the script above is setting the output value to \texttt{true} if:
\begin{itemize}[noitemsep]
\item A new path is available. \\
This happens when the path flag was called at least once and the \textit{Robotino} is not driving any more or has performed a short stop between the sub-paths.
The output is \texttt{true} as long as the path-step is not \texttt{1}, since then the path will be driven normally.
\item The next sub-path step should be driven because the path-driver has finished the previous one.
\end{itemize}
\subsubsection{Path driving}
\insertpicture{images/pathdriver}{Path driver logic (simplified)}{(self-made)}{fig:pathdriver}{0.9}
Once the path-driver gets a new position out of the path-file, the \textit{Robotino} drives to the gathered position and turns into the final pose.
The path-driver block is therefore set to holonomic driving and then holonomic turning. \\
% The path driver always needs the odometry. This is why these values were also passed to it.
Once the path driver has received the new values of a position it is waiting for it's last input (marked with "Neustart" in Figure \ref{fig:pathdriver}) to turn \texttt{true} so it will actually start to drive the sub-path.  \\
As long as the robot is still driving the path, the terminator-Lua-Script has \texttt{1} as output. The terminator-Lua-script checks if the incremental counter equals the stopping condition, which is a \texttt{0}, and if so the robot stops driving. \\
The decision for the next sub-path is done by the \texttt{AND-flag} at the bottom. This value is \texttt{true} if the terminator has not yet terminated the path and the path-driver is currently not driving the previous sub-path any more.\\ Finally, the path driver does all the calculations for the motor velocities for the x and y direction and the rotation and passes them on to the engine. The path driver finally signals if the sub-path endpoint has been reached whenever it's last output (marked with "Pose erreicht" in Figure \ref{fig:pathdriver}) is \texttt{true}.
\subsubsection{Emergency and controlled Stops}
\label{subsubsec:stoppingtherobotino}
In industrial environments it is common, if not even necessary due to regulations, to implement emergency stops mechanisms. \textit{RoboNav} implemets a "soft" version of these very important functions.
\insertpicture{images/stops}{Emergency and slow stop}{(self-made)}{fig:stop}{1.0}
%First of all, the robot is stopping by himself if the sensors report any obstacle which is too near. 
A possibility for sending an emergency stop from \textit{RoboNav Control} has been implemented. 
\textit{RoboNav Control} is able to send such an emergency stop command. The signal is sent via the emergency-stop-file and the stop-logic is situated immediately between the path-driver and the direct control of the engine, so as close to the engine as possible. \\
If the content of the emergency-file is \texttt{1}, the negated value will be \texttt{0}. When the velocity values which the path-driver passes on to the driving logic of the \textit{Robotino} are multiplied with \texttt{0} they are \texttt{0}, which means that the robot won't drive. Of course, it works the same way with the terminating value as well. \\
Normally, an \textit{real} emergency stop implementation would need an restart of the system, an new request of the path or setting an dedicated start command but this type of simulated stop was enough for \textit{RoboNav}'s overall purposes. \\\\
The slow-stop on the other hand causes the robot to finish the current sub-path and then stop. The logic for stopping at the next subpath causes the decision of the next subpath to delay until the slow-stop-signal is deactivated.






